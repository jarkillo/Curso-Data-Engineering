# Tema 1: APIs REST - Ejercicios Pr√°cticos

**M√≥dulo 4: APIs y Web Scraping**
**Master en Ingenier√≠a de Datos**

---

## üìö Introducci√≥n

Este documento contiene **15 ejercicios progresivos** para practicar consumo de APIs REST. Cada ejercicio incluye:
- ‚úÖ Enunciado claro
- ‚úÖ Contexto empresarial
- ‚úÖ Pistas para resolverlo
- ‚úÖ Soluci√≥n completa al final

**Empresa ficticia:** DataHub Inc.

**Progresi√≥n de dificultad:**
- üìó **Ejercicios 1-5:** B√°sico (principiantes)
- üìô **Ejercicios 6-10:** Intermedio (con experiencia)
- üìï **Ejercicios 11-15:** Avanzado (integraci√≥n completa)

---

## üéØ C√≥mo Usar Este Documento

1. **Intenta resolver el ejercicio por tu cuenta** (15-30 minutos)
2. Si te atascas, lee las **pistas**
3. Si sigues atascado, consulta la **soluci√≥n**
4. **Ejecuta el c√≥digo** para verificar que funciona
5. **Modifica el c√≥digo** para experimentar

**üí° Consejo:** No leas las soluciones directamente. Aprender√°s mucho m√°s resolviendo los ejercicios por tu cuenta.

---

## üìó EJERCICIOS B√ÅSICOS (1-5)

### Ejercicio 1: GET Request a API P√∫blica üåü

**Nivel:** B√°sico
**Duraci√≥n:** 10-15 minutos

**Contexto:**
Tu jefe en DataHub Inc. te pide extraer todos los posts de la API de JSONPlaceholder y contar cu√°ntos hay.

**Requerimiento:**
1. Hacer GET request a `https://jsonplaceholder.typicode.com/posts`
2. Contar el total de posts
3. Mostrar el t√≠tulo del primer post

**Criterios de √©xito:**
- ‚úÖ El c√≥digo imprime el total de posts (debe ser 100)
- ‚úÖ El c√≥digo imprime el t√≠tulo del primer post
- ‚úÖ Validas el status code antes de procesar

**Pistas:**
- Usa `requests.get(url)`
- Usa `response.json()` para obtener la lista
- Usa `len()` para contar elementos

**C√≥digo base:**
```python
import requests

# Tu c√≥digo aqu√≠
```

---

### Ejercicio 2: Extraer Campos Espec√≠ficos üîç

**Nivel:** B√°sico
**Duraci√≥n:** 10-15 minutos

**Contexto:**
DataHub Inc. necesita un reporte de los primeros 5 posts con solo el t√≠tulo y el body.

**Requerimiento:**
1. Obtener todos los posts de JSONPlaceholder
2. Extraer solo los primeros 5
3. Para cada uno, mostrar: ID, t√≠tulo (primeros 30 caracteres), body (primeros 50 caracteres)

**Criterios de √©xito:**
- ‚úÖ Muestra exactamente 5 posts
- ‚úÖ T√≠tulos truncados a 30 caracteres
- ‚úÖ Body truncado a 50 caracteres
- ‚úÖ Formato legible

**Pistas:**
- Usa slicing para limitar: `posts[:5]`
- Usa slicing para truncar strings: `titulo[:30]`
- Usa f-strings para formatear

---

### Ejercicio 3: Filtrar con Query Parameters üéØ

**Nivel:** B√°sico
**Duraci√≥n:** 15-20 minutos

**Contexto:**
Tu equipo necesita solo los posts del usuario con ID 1.

**Requerimiento:**
1. Hacer GET request a `https://jsonplaceholder.typicode.com/posts`
2. Usar query parameter `userId=1` para filtrar
3. Contar cu√°ntos posts tiene ese usuario
4. Mostrar los t√≠tulos de todos sus posts

**Criterios de √©xito:**
- ‚úÖ Solo obtienes posts del userId=1 (debe ser 10 posts)
- ‚úÖ Usas `params` en requests
- ‚úÖ Muestras todos los t√≠tulos

**Pistas:**
- Usa `params={"userId": 1}` en requests.get()
- La API filtra autom√°ticamente

---

### Ejercicio 4: Validar Status Codes üö¶

**Nivel:** B√°sico
**Duraci√≥n:** 15-20 minutos

**Contexto:**
DataHub Inc. necesita una funci√≥n robusta que maneje diferentes status codes.

**Requerimiento:**
Crear una funci√≥n que:
1. Recibe una URL
2. Hace GET request
3. Si status 200: imprime "‚úÖ √âxito"
4. Si status 404: imprime "‚ùå Recurso no encontrado"
5. Si status 401: imprime "‚ùå No autenticado"
6. Cualquier otro: imprime "‚ùå Error {status_code}"
7. Prueba con estas URLs:
   - `https://jsonplaceholder.typicode.com/posts/1` (200)
   - `https://jsonplaceholder.typicode.com/posts/999` (404)

**Criterios de √©xito:**
- ‚úÖ Funci√≥n con firma: `validar_status(url: str) -> None`
- ‚úÖ Maneja los 3 status codes correctamente
- ‚úÖ Muestra el status code en el mensaje

**Pistas:**
- Usa `if/elif/else` para los diferentes c√≥digos
- Usa `response.status_code`

---

### Ejercicio 5: Guardar Datos en CSV üíæ

**Nivel:** B√°sico
**Duraci√≥n:** 20-25 minutos

**Contexto:**
Tu jefe quiere un CSV con los primeros 10 posts para an√°lisis.

**Requerimiento:**
1. Obtener los primeros 10 posts
2. Guardarlos en `posts.csv` con columnas: `id, userId, title, body`
3. El t√≠tulo debe truncarse a 50 caracteres m√°ximo
4. El body debe truncarse a 100 caracteres m√°ximo

**Criterios de √©xito:**
- ‚úÖ Archivo `posts.csv` creado
- ‚úÖ Contiene 10 filas (+ header)
- ‚úÖ T√≠tulos y body truncados correctamente
- ‚úÖ CSV bien formateado (sin errores al abrirlo en Excel)

**Pistas:**
- Usa `import csv`
- Usa `with open("posts.csv", "w", newline="", encoding="utf-8") as f:`
- Usa `csv.writer(f)`

---

## üìô EJERCICIOS INTERMEDIOS (6-10)

### Ejercicio 6: POST Request para Crear Recurso ‚ûï

**Nivel:** Intermedio
**Duraci√≥n:** 20-25 minutos

**Contexto:**
DataHub Inc. necesita crear un nuevo post en la API de prueba.

**Requerimiento:**
1. Crear un POST request a `https://jsonplaceholder.typicode.com/posts`
2. Enviar estos datos:
   ```python
   {
       "title": "ETL Pipeline con Python",
       "body": "Gu√≠a completa de implementaci√≥n de pipelines ETL",
       "userId": 1
   }
   ```
3. Validar que el status code sea 201
4. Mostrar el ID asignado por el servidor

**Criterios de √©xito:**
- ‚úÖ Status code es 201
- ‚úÖ Usas `json=` (no `data=`)
- ‚úÖ Imprimes el ID del recurso creado

**Pistas:**
- Usa `requests.post(url, json=datos)`
- Verifica `response.status_code == 201`

---

### Ejercicio 7: PUT Request para Actualizar üîÑ

**Nivel:** Intermedio
**Duraci√≥n:** 20-25 minutos

**Contexto:**
Necesitas actualizar el post con ID 1.

**Requerimiento:**
1. Hacer GET a `https://jsonplaceholder.typicode.com/posts/1` para obtener el post actual
2. Modificar el t√≠tulo a "ACTUALIZADO: " + t√≠tulo_original
3. Hacer PUT a la misma URL con los datos modificados
4. Validar que el status code sea 200
5. Mostrar el t√≠tulo actualizado

**Criterios de √©xito:**
- ‚úÖ Haces GET primero
- ‚úÖ Modificas el t√≠tulo correctamente
- ‚úÖ Haces PUT con todos los datos
- ‚úÖ Status code es 200

**Pistas:**
- GET primero: `post = requests.get(url).json()`
- Modifica: `post["title"] = "ACTUALIZADO: " + post["title"]`
- PUT: `requests.put(url, json=post)`

---

### Ejercicio 8: DELETE Request üóëÔ∏è

**Nivel:** Intermedio
**Duraci√≥n:** 15-20 minutos

**Contexto:**
DataHub Inc. necesita eliminar el post con ID 1.

**Requerimiento:**
1. Hacer DELETE a `https://jsonplaceholder.typicode.com/posts/1`
2. Validar que el status code sea 200 o 204
3. Intentar hacer GET al mismo post
4. Verificar que devuelve 404 (nota: JSONPlaceholder no elimina realmente, as√≠ que devolver√° 200, pero simula el flujo)

**Criterios de √©xito:**
- ‚úÖ DELETE request exitoso
- ‚úÖ Validaci√≥n de status code
- ‚úÖ Intentas GET posterior

**Pistas:**
- Usa `requests.delete(url)`
- Status 200 o 204 indican √©xito

---

### Ejercicio 9: Paginaci√≥n Manual ‚è≠Ô∏è

**Nivel:** Intermedio
**Duraci√≥n:** 25-30 minutos

**Contexto:**
Tu equipo necesita los primeros 30 posts, pero la API devuelve solo 10 por p√°gina.

**Requerimiento:**
1. Iterar 3 p√°ginas manualmente
2. Usar par√°metros `_page` y `_limit`
3. Consolidar todos los posts en una sola lista
4. Mostrar el total de posts descargados

**Criterios de √©xito:**
- ‚úÖ Descargas exactamente 30 posts
- ‚úÖ Usas un loop para las 3 p√°ginas
- ‚úÖ Usas `_page=1`, `_page=2`, `_page=3`
- ‚úÖ Usas `_limit=10`

**Pistas:**
- Usa `for pagina in range(1, 4):`
- Usa `params={"_page": pagina, "_limit": 10}`
- Usa `todos_posts.extend(posts)` para consolidar

---

### Ejercicio 10: Detectar y Manejar Error 429 üö®

**Nivel:** Intermedio
**Duraci√≥n:** 20-25 minutos

**Contexto:**
DataHub Inc. necesita un sistema que detecte rate limiting.

**Requerimiento:**
1. Crear funci√≥n `hacer_request_con_rate_limit(url)`
2. Simula rate limit usando `https://httpstat.us/429`
3. Si recibe 429, espera 5 segundos y reintenta (m√°ximo 2 veces)
4. Si recibe 200, devuelve la respuesta
5. Si falla despu√©s de 2 reintentos, lanza excepci√≥n

**Criterios de √©xito:**
- ‚úÖ Detecta status 429
- ‚úÖ Espera 5 segundos antes de reintentar
- ‚úÖ M√°ximo 2 reintentos
- ‚úÖ Muestra mensajes informativos

**Pistas:**
- Usa `import time` y `time.sleep(5)`
- Usa un loop con contador de intentos
- Usa `if response.status_code == 429:`

---

## üìï EJERCICIOS AVANZADOS (11-15)

### Ejercicio 11: Reintentos con Exponential Backoff ‚è±Ô∏è

**Nivel:** Avanzado
**Duraci√≥n:** 30-35 minutos

**Contexto:**
Tu equipo necesita un cliente robusto que maneje errores 5xx.

**Requerimiento:**
Crear funci√≥n `hacer_request_robusto(url, max_intentos=3)` que:
1. Hace GET request
2. Si recibe 200: devuelve response
3. Si recibe 5xx (500, 502, 503, 504): reintenta con exponential backoff
   - Intento 1: espera 2 segundos
   - Intento 2: espera 4 segundos
   - Intento 3: espera 8 segundos
4. Si recibe 4xx (excepto 429): lanza ValueError (error permanente)
5. Si recibe 429: reintenta como 5xx
6. Si falla despu√©s de max_intentos: lanza RuntimeError

**Criterios de √©xito:**
- ‚úÖ Implementa exponential backoff correctamente
- ‚úÖ Distingue errores temporales (5xx) de permanentes (4xx)
- ‚úÖ 429 se trata como temporal
- ‚úÖ Muestra logs de cada intento

**Pistas:**
- Delay: `delay = 2 ** intento`
- Usa `time.sleep(delay)`
- Usa `try/except` para manejar errores

---

### Ejercicio 12: Paginaci√≥n Autom√°tica Completa üîÑ

**Nivel:** Avanzado
**Duraci√≥n:** 30-35 minutos

**Contexto:**
DataHub Inc. necesita descargar TODOS los posts de la API sin saber cu√°ntos hay.

**Requerimiento:**
Crear funci√≥n `descargar_todos_posts()` que:
1. Itera p√°ginas autom√°ticamente (empieza en p√°gina 1)
2. Para cuando recibe lista vac√≠a
3. Usa `_limit=10`
4. Devuelve lista con todos los posts
5. Muestra progreso: "P√°gina X: Y posts descargados"

**Criterios de √©xito:**
- ‚úÖ Descarga los 100 posts
- ‚úÖ No hardcodeas el n√∫mero de p√°ginas
- ‚úÖ Para autom√°ticamente cuando no hay m√°s datos
- ‚úÖ Muestra progreso en consola

**Pistas:**
- Usa `while True:` con `break` cuando `not posts`
- Incrementa p√°gina en cada iteraci√≥n
- Usa `todos_posts.extend(posts)`

---

### Ejercicio 13: Paginaci√≥n con Cursor üîó

**Nivel:** Avanzado
**Duraci√≥n:** 35-40 minutos

**Contexto:**
Una API avanzada usa cursor-based pagination.

**Requerimiento:**
Simula cursor-based pagination:
1. Primera p√°gina: `GET /posts?_start=0&_limit=10`
2. Segunda p√°gina: `GET /posts?_start=10&_limit=10`
3. Contin√∫a hasta que la respuesta est√© vac√≠a
4. Implementa funci√≥n `descargar_con_cursor(limite=10)`

**Criterios de √©xito:**
- ‚úÖ Usa `_start` como cursor
- ‚úÖ Incrementa cursor correctamente: `cursor += limite`
- ‚úÖ Para cuando no hay m√°s datos
- ‚úÖ Descarga todos los posts

**Pistas:**
- Cursor inicial: `cursor = 0`
- Par√°metros: `{"_start": cursor, "_limit": limite}`
- Actualiza cursor: `cursor += limite`

---

### Ejercicio 14: Comparar M√©todos de Autenticaci√≥n üîê

**Nivel:** Avanzado
**Duraci√≥n:** 40-45 minutos

**Contexto:**
DataHub Inc. necesita documentaci√≥n de los 3 m√©todos de autenticaci√≥n.

**Requerimiento:**
Crear 3 funciones:
1. `crear_headers_api_key(api_key: str) -> dict`
   - Devuelve `{"X-API-Key": api_key}`
2. `crear_headers_bearer(token: str) -> dict`
   - Devuelve `{"Authorization": f"Bearer {token}"}`
3. `crear_headers_basic_auth(usuario: str, password: str) -> dict`
   - Codifica en base64: `usuario:password`
   - Devuelve `{"Authorization": f"Basic {encoded}"}`

Luego:
4. Prueba cada funci√≥n imprimiendo los headers
5. Documenta ventajas y desventajas de cada m√©todo

**Criterios de √©xito:**
- ‚úÖ 3 funciones implementadas correctamente
- ‚úÖ Basic Auth codifica en base64
- ‚úÖ Headers formateados correctamente
- ‚úÖ Documentaci√≥n de ventajas/desventajas

**Pistas:**
- Usa `import base64`
- Codifica: `base64.b64encode(b"usuario:password").decode()`

---

### Ejercicio 15: Pipeline ETL Completo üöÄ

**Nivel:** Avanzado
**Duraci√≥n:** 45-60 minutos

**Contexto:**
DataHub Inc. necesita un pipeline ETL completo: Extraer de API ‚Üí Transformar ‚Üí Cargar en CSV.

**Requerimiento:**
Crear pipeline completo:

1. **EXTRACT:** Descargar todos los posts de JSONPlaceholder
2. **TRANSFORM:**
   - A√±adir columna `titulo_largo` (True si t√≠tulo > 50 caracteres)
   - A√±adir columna `body_largo` (True si body > 200 caracteres)
   - Filtrar solo posts del userId 1-3
   - Ordenar por userId, luego por id
3. **LOAD:** Guardar en `posts_procesados.csv`

**Estructura sugerida:**
```python
def extract() -> list:
    """Extrae posts de la API."""
    pass

def transform(posts: list) -> list:
    """Transforma los posts."""
    pass

def load(posts: list, filename: str) -> None:
    """Guarda en CSV."""
    pass

def pipeline():
    """Pipeline completo."""
    posts = extract()
    posts_transformados = transform(posts)
    load(posts_transformados, "posts_procesados.csv")
    print(f"‚úÖ Pipeline completado: {len(posts_transformados)} posts procesados")

if __name__ == "__main__":
    pipeline()
```

**Criterios de √©xito:**
- ‚úÖ Extract descarga todos los posts (100)
- ‚úÖ Transform a√±ade 2 columnas calculadas
- ‚úÖ Transform filtra correctamente (userId 1-3 = 30 posts)
- ‚úÖ Transform ordena correctamente
- ‚úÖ Load crea CSV v√°lido con 6 columnas
- ‚úÖ Pipeline se ejecuta sin errores

**Pistas:**
- Extract: Reutiliza ejercicio 12
- Transform: Usa list comprehension
- Load: Usa `csv.DictWriter` para mantener columnas

---

## ‚úÖ Autoevaluaci√≥n

Marca los ejercicios que completaste:

**B√°sicos (1-5):**
- [ ] Ejercicio 1: GET Request b√°sico
- [ ] Ejercicio 2: Extraer campos espec√≠ficos
- [ ] Ejercicio 3: Filtrar con query parameters
- [ ] Ejercicio 4: Validar status codes
- [ ] Ejercicio 5: Guardar en CSV

**Intermedios (6-10):**
- [ ] Ejercicio 6: POST request
- [ ] Ejercicio 7: PUT request
- [ ] Ejercicio 8: DELETE request
- [ ] Ejercicio 9: Paginaci√≥n manual
- [ ] Ejercicio 10: Manejar error 429

**Avanzados (11-15):**
- [ ] Ejercicio 11: Exponential backoff
- [ ] Ejercicio 12: Paginaci√≥n autom√°tica
- [ ] Ejercicio 13: Paginaci√≥n con cursor
- [ ] Ejercicio 14: Comparar autenticaci√≥n
- [ ] Ejercicio 15: Pipeline ETL completo

**Progreso:**
- **0-5 completados:** üìó Principiante - ¬°Sigue practicando!
- **6-10 completados:** üìô Intermedio - ¬°Buen progreso!
- **11-15 completados:** üìï Avanzado - ¬°Excelente dominio!

---

## üìö SOLUCIONES

<details>
<summary><b>‚ö†Ô∏è SPOILER ALERT: Click para ver las soluciones</b></summary>

### Soluci√≥n Ejercicio 1

```python
import requests

# Hacer GET request
url = "https://jsonplaceholder.typicode.com/posts"
response = requests.get(url)

# Validar status code
if response.status_code == 200:
    posts = response.json()

    # Contar total
    total = len(posts)
    print(f"Total de posts: {total}")

    # Primer post
    primer_post = posts[0]
    print(f"T√≠tulo del primer post: {primer_post['title']}")
else:
    print(f"Error: Status code {response.status_code}")
```

**Salida esperada:**
```
Total de posts: 100
T√≠tulo del primer post: sunt aut facere repellat provident occaecati excepturi optio reprehenderit
```

---

### Soluci√≥n Ejercicio 2

```python
import requests

url = "https://jsonplaceholder.typicode.com/posts"
response = requests.get(url)

if response.status_code == 200:
    posts = response.json()

    # Primeros 5 posts
    primeros_cinco = posts[:5]

    print("=== Primeros 5 Posts ===\n")

    for post in primeros_cinco:
        id_post = post['id']
        titulo = post['title'][:30]
        body = post['body'][:50]

        print(f"ID: {id_post}")
        print(f"T√≠tulo: {titulo}...")
        print(f"Body: {body}...")
        print("-" * 50)
else:
    print(f"Error: Status code {response.status_code}")
```

**Salida esperada:**
```
=== Primeros 5 Posts ===

ID: 1
T√≠tulo: sunt aut facere repellat pro...
Body: quia et suscipit
suscipit recusandae consequu...
--------------------------------------------------
...
```

---

### Soluci√≥n Ejercicio 3

```python
import requests

url = "https://jsonplaceholder.typicode.com/posts"

# Filtrar por userId con query parameter
params = {"userId": 1}
response = requests.get(url, params=params)

if response.status_code == 200:
    posts = response.json()

    print(f"Total de posts del usuario 1: {len(posts)}")
    print("\n=== T√≠tulos ===\n")

    for post in posts:
        print(f"{post['id']}. {post['title']}")
else:
    print(f"Error: Status code {response.status_code}")
```

**Salida esperada:**
```
Total de posts del usuario 1: 10

=== T√≠tulos ===

1. sunt aut facere repellat provident occaecati excepturi optio reprehenderit
2. qui est esse
3. ea molestias quasi exercitationem repellat qui ipsa sit aut
...
```

---

### Soluci√≥n Ejercicio 4

```python
import requests

def validar_status(url: str) -> None:
    """Valida el status code de una URL."""
    response = requests.get(url)
    status = response.status_code

    if status == 200:
        print(f"‚úÖ √âxito (status {status})")
    elif status == 404:
        print(f"‚ùå Recurso no encontrado (status {status})")
    elif status == 401:
        print(f"‚ùå No autenticado (status {status})")
    else:
        print(f"‚ùå Error {status}")

# Probar con diferentes URLs
print("Probando URL v√°lida:")
validar_status("https://jsonplaceholder.typicode.com/posts/1")

print("\nProbando URL inexistente:")
validar_status("https://jsonplaceholder.typicode.com/posts/999")
```

**Salida esperada:**
```
Probando URL v√°lida:
‚úÖ √âxito (status 200)

Probando URL inexistente:
‚ùå Recurso no encontrado (status 404)
```

---

### Soluci√≥n Ejercicio 5

```python
import requests
import csv

url = "https://jsonplaceholder.typicode.com/posts"
response = requests.get(url)

if response.status_code == 200:
    posts = response.json()

    # Primeros 10 posts
    primeros_diez = posts[:10]

    # Guardar en CSV
    with open("posts.csv", "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)

        # Header
        writer.writerow(["id", "userId", "title", "body"])

        # Datos
        for post in primeros_diez:
            writer.writerow([
                post["id"],
                post["userId"],
                post["title"][:50],  # Truncar a 50
                post["body"][:100]   # Truncar a 100
            ])

    print(f"‚úÖ {len(primeros_diez)} posts guardados en posts.csv")
else:
    print(f"‚ùå Error: Status code {response.status_code}")
```

**Salida esperada:**
```
‚úÖ 10 posts guardados en posts.csv
```

---

### Soluci√≥n Ejercicio 6

```python
import requests
import json

url = "https://jsonplaceholder.typicode.com/posts"

# Datos a enviar
nuevo_post = {
    "title": "ETL Pipeline con Python",
    "body": "Gu√≠a completa de implementaci√≥n de pipelines ETL",
    "userId": 1
}

# POST request
response = requests.post(url, json=nuevo_post)

# Validar status code
if response.status_code == 201:
    post_creado = response.json()
    print("‚úÖ Post creado exitosamente")
    print(f"   ID asignado: {post_creado['id']}")
    print(f"   T√≠tulo: {post_creado['title']}")
    print(f"\n   Respuesta completa:")
    print(json.dumps(post_creado, indent=2, ensure_ascii=False))
else:
    print(f"‚ùå Error: Status code {response.status_code}")
```

**Salida esperada:**
```
‚úÖ Post creado exitosamente
   ID asignado: 101
   T√≠tulo: ETL Pipeline con Python

   Respuesta completa:
{
  "title": "ETL Pipeline con Python",
  "body": "Gu√≠a completa de implementaci√≥n de pipelines ETL",
  "userId": 1,
  "id": 101
}
```

---

### Soluci√≥n Ejercicio 7

```python
import requests

url = "https://jsonplaceholder.typicode.com/posts/1"

# 1. GET para obtener el post actual
response_get = requests.get(url)

if response_get.status_code == 200:
    post = response_get.json()
    print(f"T√≠tulo original: {post['title']}")

    # 2. Modificar el t√≠tulo
    post["title"] = "ACTUALIZADO: " + post["title"]

    # 3. PUT para actualizar
    response_put = requests.put(url, json=post)

    if response_put.status_code == 200:
        post_actualizado = response_put.json()
        print(f"‚úÖ Post actualizado")
        print(f"   T√≠tulo nuevo: {post_actualizado['title']}")
    else:
        print(f"‚ùå Error en PUT: Status {response_put.status_code}")
else:
    print(f"‚ùå Error en GET: Status {response_get.status_code}")
```

**Salida esperada:**
```
T√≠tulo original: sunt aut facere repellat provident occaecati excepturi optio reprehenderit
‚úÖ Post actualizado
   T√≠tulo nuevo: ACTUALIZADO: sunt aut facere repellat provident occaecati excepturi optio reprehenderit
```

---

### Soluci√≥n Ejercicio 8

```python
import requests

url = "https://jsonplaceholder.typicode.com/posts/1"

# 1. DELETE request
response_delete = requests.delete(url)

if response_delete.status_code in [200, 204]:
    print(f"‚úÖ Post eliminado (status {response_delete.status_code})")

    # 2. Intentar GET para verificar (en JSONPlaceholder no se elimina realmente)
    response_get = requests.get(url)

    if response_get.status_code == 404:
        print("‚úÖ Confirmado: Post no existe (404)")
    else:
        print(f"‚ÑπÔ∏è  Nota: JSONPlaceholder es API de prueba, no elimina realmente")
        print(f"   Status GET: {response_get.status_code}")
else:
    print(f"‚ùå Error en DELETE: Status {response_delete.status_code}")
```

**Salida esperada:**
```
‚úÖ Post eliminado (status 200)
‚ÑπÔ∏è  Nota: JSONPlaceholder es API de prueba, no elimina realmente
   Status GET: 200
```

---

### Soluci√≥n Ejercicio 9

```python
import requests

base_url = "https://jsonplaceholder.typicode.com/posts"

todos_posts = []

# Iterar 3 p√°ginas
for pagina in range(1, 4):
    params = {
        "_page": pagina,
        "_limit": 10
    }

    response = requests.get(base_url, params=params)

    if response.status_code == 200:
        posts = response.json()
        todos_posts.extend(posts)
        print(f"‚úÖ P√°gina {pagina}: {len(posts)} posts descargados")
    else:
        print(f"‚ùå Error en p√°gina {pagina}: Status {response.status_code}")
        break

print(f"\nüìä Total descargado: {len(todos_posts)} posts")
```

**Salida esperada:**
```
‚úÖ P√°gina 1: 10 posts descargados
‚úÖ P√°gina 2: 10 posts descargados
‚úÖ P√°gina 3: 10 posts descargados

üìä Total descargado: 30 posts
```

---

### Soluci√≥n Ejercicio 10

```python
import requests
import time

def hacer_request_con_rate_limit(url: str) -> requests.Response:
    """Hace request con manejo de rate limiting."""
    max_intentos = 2

    for intento in range(1, max_intentos + 1):
        print(f"Intento {intento}/{max_intentos}...")

        response = requests.get(url)

        if response.status_code == 200:
            print("‚úÖ √âxito")
            return response
        elif response.status_code == 429:
            if intento < max_intentos:
                print(f"‚ùå Rate limit alcanzado (429). Esperando 5 segundos...")
                time.sleep(5)
            else:
                raise RuntimeError("Rate limit alcanzado despu√©s de reintentos")
        else:
            raise RuntimeError(f"Error inesperado: {response.status_code}")

    raise RuntimeError(f"Fall√≥ despu√©s de {max_intentos} intentos")

# Probar con API que simula 429
url = "https://httpstat.us/429"

try:
    response = hacer_request_con_rate_limit(url)
    print(f"Respuesta: {response.text}")
except RuntimeError as e:
    print(f"‚ùå Error: {e}")
```

**Salida esperada:**
```
Intento 1/2...
‚ùå Rate limit alcanzado (429). Esperando 5 segundos...
Intento 2/2...
‚ùå Error: Rate limit alcanzado despu√©s de reintentos
```

---

### Soluci√≥n Ejercicio 11

```python
import requests
import time

def hacer_request_robusto(url: str, max_intentos: int = 3) -> requests.Response:
    """Hace request con exponential backoff."""
    for intento in range(1, max_intentos + 1):
        print(f"\nüîÑ Intento {intento}/{max_intentos}")

        try:
            response = requests.get(url, timeout=30)

            # √âxito
            if response.status_code == 200:
                print("‚úÖ √âxito")
                return response

            # Error temporal (reintentar)
            if response.status_code in [500, 502, 503, 504, 429]:
                if intento < max_intentos:
                    delay = 2 ** intento  # Exponential backoff
                    print(f"‚ùå Error temporal {response.status_code}")
                    print(f"‚è≥ Esperando {delay} segundos...")
                    time.sleep(delay)
                    continue
                else:
                    raise RuntimeError(f"Fall√≥ despu√©s de {max_intentos} intentos")

            # Error permanente (no reintentar)
            if 400 <= response.status_code < 500:
                raise ValueError(f"Error permanente {response.status_code}")

        except requests.exceptions.Timeout:
            if intento < max_intentos:
                delay = 2 ** intento
                print(f"‚è±Ô∏è  Timeout")
                print(f"‚è≥ Esperando {delay} segundos...")
                time.sleep(delay)
                continue
            else:
                raise RuntimeError("Timeout despu√©s de m√∫ltiples reintentos")

    raise RuntimeError(f"Fall√≥ despu√©s de {max_intentos} intentos")

# Probar con API real
url = "https://jsonplaceholder.typicode.com/posts/1"

try:
    response = hacer_request_robusto(url)
    post = response.json()
    print(f"\n‚úÖ Post obtenido: {post['title'][:50]}...")
except Exception as e:
    print(f"\n‚ùå Error: {e}")
```

**Salida esperada:**
```
üîÑ Intento 1/3
‚úÖ √âxito

‚úÖ Post obtenido: sunt aut facere repellat provident occaecati...
```

---

### Soluci√≥n Ejercicio 12

```python
import requests

def descargar_todos_posts() -> list:
    """Descarga todos los posts con paginaci√≥n autom√°tica."""
    base_url = "https://jsonplaceholder.typicode.com/posts"
    todos_posts = []
    pagina = 1
    limite_por_pagina = 10

    print("=== Paginaci√≥n Autom√°tica ===\n")

    while True:
        params = {
            "_page": pagina,
            "_limit": limite_por_pagina
        }

        response = requests.get(base_url, params=params)

        if response.status_code == 200:
            posts = response.json()

            # Si no hay m√°s posts, terminar
            if not posts:
                print(f"‚úÖ Paginaci√≥n completa")
                break

            todos_posts.extend(posts)
            print(f"P√°gina {pagina}: {len(posts)} posts descargados")

            pagina += 1
        else:
            print(f"‚ùå Error: Status {response.status_code}")
            break

    return todos_posts

# Ejecutar
posts = descargar_todos_posts()
print(f"\nüìä Total: {len(posts)} posts")
```

**Salida esperada:**
```
=== Paginaci√≥n Autom√°tica ===

P√°gina 1: 10 posts descargados
P√°gina 2: 10 posts descargados
...
P√°gina 10: 10 posts descargados
‚úÖ Paginaci√≥n completa

üìä Total: 100 posts
```

---

### Soluci√≥n Ejercicio 13

```python
import requests

def descargar_con_cursor(limite: int = 10) -> list:
    """Descarga posts usando cursor-based pagination."""
    base_url = "https://jsonplaceholder.typicode.com/posts"
    todos_posts = []
    cursor = 0
    pagina = 1

    print("=== Paginaci√≥n con Cursor ===\n")

    while True:
        params = {
            "_start": cursor,
            "_limit": limite
        }

        response = requests.get(base_url, params=params)

        if response.status_code == 200:
            posts = response.json()

            # Si no hay m√°s posts, terminar
            if not posts:
                print(f"‚úÖ Paginaci√≥n completa")
                break

            todos_posts.extend(posts)
            print(f"P√°gina {pagina} (cursor={cursor}): {len(posts)} posts")

            # Actualizar cursor
            cursor += limite
            pagina += 1
        else:
            print(f"‚ùå Error: Status {response.status_code}")
            break

    return todos_posts

# Ejecutar
posts = descargar_con_cursor(limite=10)
print(f"\nüìä Total: {len(posts)} posts")
```

**Salida esperada:**
```
=== Paginaci√≥n con Cursor ===

P√°gina 1 (cursor=0): 10 posts
P√°gina 2 (cursor=10): 10 posts
...
P√°gina 10 (cursor=90): 10 posts
‚úÖ Paginaci√≥n completa

üìä Total: 100 posts
```

---

### Soluci√≥n Ejercicio 14

```python
import base64

def crear_headers_api_key(api_key: str) -> dict:
    """Crea headers con API Key."""
    return {"X-API-Key": api_key}

def crear_headers_bearer(token: str) -> dict:
    """Crea headers con Bearer Token."""
    return {"Authorization": f"Bearer {token}"}

def crear_headers_basic_auth(usuario: str, password: str) -> dict:
    """Crea headers con Basic Auth."""
    credentials = f"{usuario}:{password}"
    encoded = base64.b64encode(credentials.encode()).decode()
    return {"Authorization": f"Basic {encoded}"}

# Probar las funciones
print("=== M√©todos de Autenticaci√≥n ===\n")

print("1. API Key:")
headers_api = crear_headers_api_key("sk_live_abc123")
print(f"   {headers_api}")

print("\n2. Bearer Token:")
headers_bearer = crear_headers_bearer("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")
print(f"   {headers_bearer}")

print("\n3. Basic Auth:")
headers_basic = crear_headers_basic_auth("usuario", "contrase√±a123")
print(f"   {headers_basic}")

print("\n" + "="*60)
print("COMPARACI√ìN DE M√âTODOS")
print("="*60)

print("""
| M√©todo       | Seguridad | Expiraci√≥n | Complejidad |
| ------------ | --------- | ---------- | ----------- |
| API Key      | Media     | No         | Baja        |
| Bearer Token | Alta      | S√≠         | Media       |
| Basic Auth   | Baja      | No         | Baja        |

VENTAJAS:
- API Key: Simple, no expira
- Bearer Token: Muy seguro, expira autom√°ticamente
- Basic Auth: Muy simple de implementar

DESVENTAJAS:
- API Key: Si se filtra, v√°lida para siempre
- Bearer Token: Necesitas refrescar el token
- Basic Auth: Env√≠as credenciales en cada request
""")
```

**Salida esperada:**
```
=== M√©todos de Autenticaci√≥n ===

1. API Key:
   {'X-API-Key': 'sk_live_abc123'}

2. Bearer Token:
   {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9'}

3. Basic Auth:
   {'Authorization': 'Basic dXN1YXJpbzpjb250cmFzZcOxYTEyMw=='}

============================================================
COMPARACI√ìN DE M√âTODOS
============================================================

| M√©todo       | Seguridad | Expiraci√≥n | Complejidad |
| ------------ | --------- | ---------- | ----------- |
| API Key      | Media     | No         | Baja        |
| Bearer Token | Alta      | S√≠         | Media       |
| Basic Auth   | Baja      | No         | Baja        |
...
```

---

### Soluci√≥n Ejercicio 15

```python
import requests
import csv

def extract() -> list:
    """Extrae posts de la API."""
    url = "https://jsonplaceholder.typicode.com/posts"
    todos_posts = []
    pagina = 1

    while True:
        params = {"_page": pagina, "_limit": 10}
        response = requests.get(url, params=params)

        if response.status_code == 200:
            posts = response.json()
            if not posts:
                break
            todos_posts.extend(posts)
            pagina += 1
        else:
            raise RuntimeError(f"Error en extracci√≥n: {response.status_code}")

    print(f"‚úÖ EXTRACT: {len(todos_posts)} posts descargados")
    return todos_posts

def transform(posts: list) -> list:
    """Transforma los posts."""
    posts_transformados = []

    for post in posts:
        # Filtrar solo userId 1-3
        if post["userId"] not in [1, 2, 3]:
            continue

        # A√±adir columnas calculadas
        post["titulo_largo"] = len(post["title"]) > 50
        post["body_largo"] = len(post["body"]) > 200

        posts_transformados.append(post)

    # Ordenar por userId, luego por id
    posts_transformados.sort(key=lambda p: (p["userId"], p["id"]))

    print(f"‚úÖ TRANSFORM: {len(posts_transformados)} posts procesados")
    return posts_transformados

def load(posts: list, filename: str) -> None:
    """Guarda en CSV."""
    with open(filename, "w", newline="", encoding="utf-8") as f:
        if posts:
            fieldnames = ["id", "userId", "title", "body", "titulo_largo", "body_largo"]
            writer = csv.DictWriter(f, fieldnames=fieldnames)

            writer.writeheader()
            for post in posts:
                writer.writerow({
                    "id": post["id"],
                    "userId": post["userId"],
                    "title": post["title"],
                    "body": post["body"],
                    "titulo_largo": post["titulo_largo"],
                    "body_largo": post["body_largo"]
                })

    print(f"‚úÖ LOAD: Guardado en {filename}")

def pipeline():
    """Pipeline ETL completo."""
    print("=== Pipeline ETL ===\n")

    # ETL
    posts = extract()
    posts_transformados = transform(posts)
    load(posts_transformados, "posts_procesados.csv")

    print(f"\nüéâ Pipeline completado: {len(posts_transformados)} posts procesados")

if __name__ == "__main__":
    pipeline()
```

**Salida esperada:**
```
=== Pipeline ETL ===

‚úÖ EXTRACT: 100 posts descargados
‚úÖ TRANSFORM: 30 posts procesados
‚úÖ LOAD: Guardado en posts_procesados.csv

üéâ Pipeline completado: 30 posts procesados
```

</details>

---

## üéì ¬øQu√© Sigue?

Despu√©s de completar estos ejercicios:

1. **Proyecto Pr√°ctico:** Ve a `04-proyecto-practico/` para aplicar todo lo aprendido
2. **Revisi√≥n Pedag√≥gica:** Lee `REVISION_PEDAGOGICA.md` para entender la progresi√≥n
3. **README del Tema:** Consulta `README.md` para resumen del tema

**¬°Felicidades por completar los ejercicios!** üéâ

---

*√öltima actualizaci√≥n: 2025-10-23*
*Tiempo estimado total: 6-10 horas*
